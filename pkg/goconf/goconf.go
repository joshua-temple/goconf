package goconf

import (
	"bufio"
	"fmt"
	"io/fs"
	"os"
	"path/filepath"
	"regexp"
	"runtime"
	"sort"
	"strings"
	"sync"

	"github.com/pkg/errors"
	"gopkg.in/yaml.v3"
)

// GenerateConstants generates the configuration constants file.
// It searches YAML files under the specified directories and generates a Go file with constants.
// The constants are generated based on the YAML keys and their values.
// The generated file contains a constant for each key in the YAML files.
// The constants are named using the following rules:
// - If a key has a "prefix" directive, that portion of the constant name receives the override.
//   - Otherwise, the constant name is the camel case of the key.
//
// - If a key has a "group" directive, the constant is assigned to that group.
//   - Otherwise, the group is derived from the first part of the key.
//
// - If a key has a "comment" directive, the comment is added to the constant.
func GenerateConstants(configFile, outputFile, packageName string, backup bool) error {
	var (
		trees []*Entry
	)

	// determine if configFile is a file path or directory
	if configFile == "" {
		return errors.New("no configuration file provided")
	}

	if filepath.Ext(configFile) == "" {
		err := filepath.WalkDir(configFile, func(path string, d fs.DirEntry, err error) error {
			if err != nil {
				return err
			}

			if !d.IsDir() && (strings.HasSuffix(d.Name(), ".yaml") || strings.HasSuffix(d.Name(), ".yml")) {
				t, err := ingestFile(path, backup)
				if err != nil {
					return errors.Wrap(err, "failed to ingest file")
				}

				trees = append(trees, t...)
			}
			return nil
		})
		if err != nil {
			return errors.Wrap(err, "failed to walk directory")
		}
	} else {
		if !strings.HasSuffix(configFile, ".yaml") || strings.HasSuffix(configFile, ".yml") {
			return fmt.Errorf("invalid file extension: %s (expected .yaml or .yml)", strings.ToLower(filepath.Ext(configFile)))
		}

		t, err := ingestFile(configFile, backup)
		if err != nil {
			return errors.Wrap(err, "failed to ingest file")
		}
		trees = append(trees, t...)
	}

	if len(trees) == 0 {
		return errors.New("no configuration files found")
	}

	mergedTree := mergeTrees(trees)
	leaves := flattenTree(mergedTree, []string{}, "", "", false)
	sort.Slice(leaves, func(i, j int) bool {
		if leaves[i].Group == leaves[j].Group {
			return leaves[i].FullKey < leaves[j].FullKey
		}
		return leaves[i].Group < leaves[j].Group
	})

	groups := make(map[string][]flattenResult)
	var groupOrder []string
	for _, leaf := range leaves {
		grp := leaf.Group
		groups[grp] = append(groups[grp], leaf)
	}

	for grp := range groups {
		groupOrder = append(groupOrder, grp)
	}

	sort.Strings(groupOrder)

	// take the name of configFile and apply it but w/ .go extension
	o := filepath.Base(outputFile)
	if len(strings.Split(o, ".")) > 1 && len(o) > 1 {
		o = strings.TrimSuffix(o, filepath.Ext(o)) + ".go"
	} else {
		o = o + "/config.go"
	}

	out, err := os.Create(o)
	if err != nil {
		return errors.Wrap(err, "failed to create output file")
	}

	defer out.Close()

	fmt.Fprintf(out, fmt.Sprintf("package %s\n\n", packageName))
	fmt.Fprintln(out, "// --- Auto-Generated Constants ---")
	fmt.Fprintf(out, "// DO NOT EDIT: This file was generated by goconf\n\n")
	fmt.Fprintln(out, "// Directive Usages:")
	fmt.Fprintln(out, "// \t- # prefix: <prefix>")
	fmt.Fprintln(out, "// \t- # group: <group>")
	fmt.Fprintf(out, "// \t- # comment: <comment>\n\n")
	fmt.Fprintln(out, "const (")

	currentGroup := ""
	for _, grp := range groupOrder {
		if grp != "" && grp != currentGroup {
			currentGroup = grp
			fmt.Fprintf(out, "\t// %s\n", currentGroup)
		}
		for _, leaf := range groups[grp] {
			if leaf.Comment != "" {
				for _, line := range strings.Split(leaf.Comment, "\n") {
					fmt.Fprintf(out, "\t// %s\n", line)
				}
			}
			constName := generateConstName(leaf)
			fmt.Fprintf(out, "\t%s = \"%s\"\n", constName, leaf.FullKey)
		}
		fmt.Fprintln(out)
	}

	fmt.Fprintln(out, ")")
	return nil
}

// UpdateConstants performs the constant renaming update.
// It reads the new and old constant files, and updates the .go files in the provided directories.
// If dry is true, it only shows the modifications without writing changes.
// If backup is true, it creates a backup file before writing changes.
func UpdateConstants(old, new string, dry, backup bool, directories []string) error {
	newConsts, err := parseConstants(new)
	if err != nil {
		return fmt.Errorf("error parsing new file: %v", err)
	}

	oldConsts, err := parseConstants(old)
	if err != nil {
		return fmt.Errorf("error parsing old file: %v", err)
	}

	// Build mapping: old constant -> new constant (matching by identical value)
	mapping := make(map[string]string)
	for newName, newValue := range newConsts {
		for oldName, oldValue := range oldConsts {
			if newValue == oldValue {
				mapping[oldName] = newName
			}
		}
	}

	if len(mapping) == 0 {
		fmt.Println("No matching constants found.")
		return nil
	}

	// Channel to send .go file paths.
	fileChan := make(chan string, 100)

	// WaitGroup for worker goroutines.
	var wg sync.WaitGroup
	var mu sync.Mutex
	var firstErr error

	// Worker function processes files from the channel.
	worker := func() {
		defer wg.Done()
		for path := range fileChan {
			info, err := os.Stat(path)
			if err != nil {
				mu.Lock()
				if firstErr == nil {
					firstErr = errors.Wrap(err, "failed to stat file")
				}
				mu.Unlock()
				continue
			}
			data, err := os.ReadFile(path)
			if err != nil {
				mu.Lock()
				if firstErr == nil {
					firstErr = errors.Wrap(err, "failed to read file")
				}
				mu.Unlock()
				continue
			}

			original := string(data)
			modified := original
			for oldName, newName := range mapping {
				pattern := `\b` + regexp.QuoteMeta(oldName) + `\b`
				re := regexp.MustCompile(pattern)
				modified = re.ReplaceAllString(modified, newName)
			}

			if modified != original {
				if dry {
					fmt.Printf("File: %s\n", path)
					lines := strings.Split(original, "\n")
					for i, line := range lines {
						updatedLine := line
						for oldName, newName := range mapping {
							pattern := `\b` + regexp.QuoteMeta(oldName) + `\b`
							re := regexp.MustCompile(pattern)
							updatedLine = re.ReplaceAllString(updatedLine, newName)
						}
						if updatedLine != line {
							fmt.Printf("  Line %d:\n    Old: %s\n    New: %s\n", i+1, line, updatedLine)
						}
					}
				} else {
					// Create backup if enabled.
					if backup {
						backupPath := path + ".bak"
						if err := os.WriteFile(backupPath, []byte(original), info.Mode()); err != nil {
							mu.Lock()
							if firstErr == nil {
								firstErr = errors.Wrap(err, "failed to create backup file")
							}
							mu.Unlock()
							continue
						}
						fmt.Printf("Backup created for %s at %s\n", path, backupPath)
					}
					if err := os.WriteFile(path, []byte(modified), info.Mode()); err != nil {
						mu.Lock()
						if firstErr == nil {
							firstErr = errors.Wrap(err, "failed to write file")
						}
						mu.Unlock()
						continue
					}
					fmt.Printf("Updated %s\n", path)
				}
			}
		}
	}

	// Start worker pool using number of CPUs.
	numWorkers := runtime.NumCPU()
	wg.Add(numWorkers)
	for i := 0; i < numWorkers; i++ {
		go worker()
	}

	// Walk directories and send .go file paths to the channel.
	for _, dir := range directories {
		err = filepath.Walk(dir, func(path string, info os.FileInfo, err error) error {
			if err != nil {
				return err
			}
			if !info.IsDir() && filepath.Ext(path) == ".go" {
				fileChan <- path
			}
			return nil
		})
		if err != nil {
			close(fileChan)
			wg.Wait()
			return errors.Wrap(err, "failed to walk directory")
		}
	}
	close(fileChan)
	wg.Wait()

	return firstErr
}

// ingestFile reads a YAML file and returns a list of configuration trees.
func ingestFile(path string, backup bool) ([]*Entry, error) {
	var trees []*Entry
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, errors.Wrap(err, "failed to read file")
	}

	var root yaml.Node
	if err := yaml.Unmarshal(data, &root); err != nil {
		return nil, errors.Wrap(err, "failed to unmarshal YAML")
	}

	if backup {
		backupPath := path + ".bak"
		err = os.WriteFile(backupPath, data, 0o644)
		if err != nil {
			return nil, errors.Wrap(err, "failed to create backup file")
		}
		fmt.Printf("Backup created for %s at %s\n", path, backupPath)
	}

	if len(root.Content) > 0 && root.Content[0].Kind == yaml.MappingNode {
		removeIgnoredFromMapping(root.Content[0])
		tree := buildTree(root.Content[0])
		trees = append(trees, tree)
	}
	return trees, nil
}

// parseConstants reads a .go file and returns a mapping of constant name to its value.
func parseConstants(filePath string) (map[string]string, error) {
	constants := make(map[string]string)
	file, err := os.Open(filePath)
	if err != nil {
		return nil, errors.Wrap(err, "failed to open file")
	}
	defer file.Close()

	re := regexp.MustCompile(`(\w+)\s*=\s*"([^"]+)"`)
	scanner := bufio.NewScanner(file)
	for scanner.Scan() {
		line := scanner.Text()
		matches := re.FindStringSubmatch(line)
		if len(matches) == 3 {
			constants[matches[1]] = matches[2]
		}
	}

	return constants, scanner.Err()
}

// Entry represents a configuration entry.
type Entry struct {
	Key      string
	Override string
	Group    string
	Comment  string
	Children map[string]*Entry
}

// NewEntry creates a new Entry with the given key.
func NewEntry(key string) *Entry {
	return &Entry{Key: key, Children: make(map[string]*Entry)}
}

// merge merges the source Entry into the destination Entry.
func (e *Entry) merge(src *Entry) {
	if e.Override == "" {
		e.Override = src.Override
	}
	if e.Group == "" {
		e.Group = src.Group
	}
	if e.Comment == "" {
		e.Comment = src.Comment
	}
	for k, childSrc := range src.Children {
		if childDst, ok := e.Children[k]; ok {
			childDst.merge(childSrc)
		} else {
			e.Children[k] = childSrc
		}
	}
}

// Global ignored keys (lowercase)
var ignoredSet = make(map[string]bool)

// parentOverrides maps a full path (e.g. "path.to.node") to its effective override.
var parentOverrides = make(map[string]string)

// extractDirective extracts a directive value from a comment.
func extractDirective(comment, directive string) string {
	lines := strings.Split(comment, "\n")
	target := strings.ToLower(directive + ":")
	for _, line := range lines {
		line = strings.TrimSpace(strings.TrimPrefix(line, "#"))
		if strings.HasPrefix(strings.ToLower(line), target) {
			return strings.TrimSpace(line[len(target):])
		}
	}
	return ""
}

// wrapText wraps text to the specified width.
func wrapText(text string, width int) string {
	if len(text) <= width {
		return text
	}

	words := strings.Fields(text)

	var (
		current string
		lines   []string
	)

	for _, word := range words {
		if len(current)+len(word)+1 > width && current != "" {
			lines = append(lines, current)
			current = word
		} else {
			if current != "" {
				current += " " + word
			} else {
				current = word
			}
		}
	}

	if current != "" {
		lines = append(lines, current)
	}

	return strings.Join(lines, "\n")
}

// buildTree builds a tree structure from a YAML node.
func buildTree(node *yaml.Node) *Entry {
	root := NewEntry("")
	for i := 0; i < len(node.Content); i += 2 {
		keyNode := node.Content[i]
		valNode := node.Content[i+1]
		key := keyNode.Value

		if ignoredSet[strings.ToLower(key)] {
			continue
		}

		child := NewEntry(key)
		if keyNode.HeadComment != "" {
			if pfx := extractDirective(keyNode.HeadComment, "prefix"); pfx != "" {
				child.Override = pfx
			}
			if grp := extractDirective(keyNode.HeadComment, "group"); grp != "" {
				child.Group = grp
			}
			if comm := extractDirective(keyNode.HeadComment, "comment"); comm != "" {
				child.Comment = wrapText(comm, 120)
			}
		}

		for _, c := range []string{keyNode.LineComment, keyNode.FootComment} {
			if c != "" && child.Comment == "" {
				if comm := extractDirective(c, "comment"); comm != "" {
					child.Comment = wrapText(comm, 120)
				}
			}
		}

		if valNode.Kind == yaml.MappingNode {
			removeIgnoredFromMapping(valNode)
			subTree := buildTree(valNode)
			if child.Override == "" {
				child.Override = root.Override
			}

			child.merge(subTree)
		}

		root.Children[key] = child
	}

	return root
}

// removeIgnoredFromMapping removes ignored keys from a mapping node.
func removeIgnoredFromMapping(node *yaml.Node) {
	if node.Kind != yaml.MappingNode {
		return
	}

	var newContent []*yaml.Node
	for i := 0; i < len(node.Content); i += 2 {
		keyNode := node.Content[i]
		valNode := node.Content[i+1]
		if strings.ToLower(keyNode.Value) == "ignored" {
			if valNode.Kind == yaml.SequenceNode {
				for _, item := range valNode.Content {
					ignoredSet[strings.ToLower(item.Value)] = true
				}
			}
			continue
		}

		newContent = append(newContent, keyNode, valNode)
	}

	node.Content = newContent
}

// mergeTrees merges multiple trees into a single tree.
func mergeTrees(trees []*Entry) *Entry {
	merged := NewEntry("")
	for _, tree := range trees {
		merged.merge(tree)
	}
	return merged
}

// flattenResult represents a flattened configuration entry.
type flattenResult struct {
	FullKey           string
	Path              []string
	EffectiveOverride string
	Comment           string
	Group             string
}

// flattenTree flattens a tree structure into a list of flattenResults.
func flattenTree(e *Entry, path []string, effectiveOverride, effectiveGroup string, groupSet bool) []flattenResult {
	var results []flattenResult
	newPath := append([]string{}, path...)
	if e.Key != "" {
		newPath = append(newPath, e.Key)
	}

	for _, seg := range newPath {
		if ignoredSet[strings.ToLower(seg)] {
			return nil
		}
	}

	if e.Override != "" {
		effectiveOverride = e.Override
		if len(newPath) > 0 {
			parentOverrides[strings.Join(newPath, ".")] = e.Override
		}
	}

	newGroupSet := groupSet
	newEffectiveGroup := effectiveGroup
	if e.Group != "" {
		newEffectiveGroup = e.Group
		newGroupSet = true
	}

	if len(e.Children) == 0 && e.Key != "" {
		group := ""
		if newGroupSet {
			group = newEffectiveGroup
		} else if len(newPath) > 0 {
			group = defaultGroup(newPath[0])
		}
		fullKey := strings.Join(newPath, ".")
		results = append(results, flattenResult{
			FullKey:           fullKey,
			Path:              newPath,
			EffectiveOverride: effectiveOverride,
			Comment:           e.Comment,
			Group:             group,
		})
	}

	for _, child := range e.Children {
		childResults := flattenTree(child, newPath, effectiveOverride, newEffectiveGroup, newGroupSet)
		results = append(results, childResults...)
	}
	return results
}

// toCamelCase converts a slice of strings to camel case.
func toCamelCase(parts []string) string {
	var words []string
	for _, part := range parts {
		subparts := strings.FieldsFunc(part, func(r rune) bool {
			return r == '-' || r == '_' || r == '.'
		})

		for _, sub := range subparts {
			if sub != "" {
				words = append(words, strings.ToUpper(sub[:1])+strings.ToLower(sub[1:]))
			}
		}
	}

	return strings.Join(words, "")
}

// generateConstName generates a constant name from a flattenResult.
func generateConstName(fr flattenResult) string {
	var base string
	if fr.EffectiveOverride != "" {
		base = fr.EffectiveOverride
	} else {
		base = toCamelCase(fr.Path[:len(fr.Path)-1])
	}

	leaf := toCamelCase([]string{fr.Path[len(fr.Path)-1]})
	if strings.HasSuffix(base, leaf) {
		return base
	}

	return base + leaf
}

// defaultGroup generates a default group name from a key.
func defaultGroup(key string) string {
	parts := strings.Split(key, "-")
	for i, p := range parts {
		if len(p) > 0 {
			parts[i] = strings.ToUpper(p[:1]) + p[1:]
		}
	}

	return strings.Join(parts, "-")
}
